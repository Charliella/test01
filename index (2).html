<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 手勢互動四角錐</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Noto Sans TC', sans-serif; }
        #output_canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; transform: scaleX(-1); /* 鏡像顯示 */ }
        #three_canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; }
        #video_input { display: none; }
        
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 12px;
            color: white;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            pointer-events: none;
        }

        .controls-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 30;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 16px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 20;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
        }

        /* 按鈕樣式 */
        .btn-control {
            background-color: rgba(55, 65, 81, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        .btn-control:hover {
            background-color: rgba(75, 85, 99, 1);
            transform: translateY(-2px);
        }
        .btn-control:active {
            transform: translateY(0);
        }
        .btn-active {
            background-color: rgba(37, 99, 235, 0.8); /* Blue */
            border-color: rgba(96, 165, 250, 0.5);
        }
    </style>
</head>
<body>

    <!-- 視訊輸入 (隱藏) -->
    <video id="video_input"></video>
    
    <!-- 顯示相機影像的 Canvas (背景) -->
    <canvas id="output_canvas"></canvas>
    
    <!-- 顯示 3D 物件的 Canvas (前景) -->
    <canvas id="three_canvas"></canvas>

    <!-- UI 指示 -->
    <div class="ui-overlay">
        <h1 class="text-xl font-bold mb-2 text-cyan-400">手勢控制四角錐</h1>
        <ul class="text-sm space-y-1">
            <li class="flex items-center"><span class="w-2 h-2 bg-yellow-400 rounded-full mr-2"></span>單手移動：<b>自由旋轉</b></li>
            <li class="flex items-center"><span class="w-2 h-2 bg-pink-500 rounded-full mr-2"></span>雙手拉開：<b>展開模型</b></li>
        </ul>
        <div id="status" class="mt-3 text-xs text-gray-400">正在啟動相機...</div>
        <div id="gesture-feedback" class="mt-2 text-lg font-bold text-center text-white h-8"></div>
    </div>

    <!-- 控制按鈕區 -->
    <div class="controls-container">
        <button id="btn-reset" class="btn-control">重置視角</button>
        <button id="btn-camera" class="btn-control btn-active">開關相機</button>
        <button id="btn-skeleton" class="btn-control btn-active">顯示骨架</button>
        <button id="btn-autorotate" class="btn-control btn-active">自動旋轉</button>
    </div>

    <div id="loading" class="loading">
        正在載入 AI 模型...請稍候
    </div>

    <script>
        // --- 變數宣告 ---
        const videoElement = document.getElementById('video_input');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const threeCanvas = document.getElementById('three_canvas');
        const statusDiv = document.getElementById('status');
        const loadingDiv = document.getElementById('loading');
        const feedbackDiv = document.getElementById('gesture-feedback');

        // 控制狀態變數
        let isShowCamera = true;
        let isShowSkeleton = true;
        let isAutoRotate = true;

        // Three.js 相關變數
        let scene, camera, renderer, pyramidGroup;
        let sidePanels = []; // 儲存四個側面，用於控制展開
        
        // 互動狀態
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetUnfoldAngle = Math.PI / 3.5; // 預設閉合角度 (約 50度)
        let currentUnfoldAngle = targetUnfoldAngle;
        
        // --- 1. 初始化 Three.js 場景 ---
        function initThree() {
            scene = new THREE.Scene();
            
            // 設定攝影機
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            camera.position.y = 1;

            // 設定渲染器
            renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // 燈光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            
            const pointLight = new THREE.PointLight(0x00ffff, 0.5);
            pointLight.position.set(-5, 0, 5);
            scene.add(pointLight);

            // 建立可展開的四角錐
            createUnfoldablePyramid();

            animateThree();
        }

        // 建立特殊的四角錐結構，使其可以展開
        function createUnfoldablePyramid() {
            pyramidGroup = new THREE.Group();
            
            const baseSize = 2;
            const height = 2; // 角錐高度
            
            // 材質
            const materialBase = new THREE.MeshPhongMaterial({ 
                color: 0x222222, 
                side: THREE.DoubleSide,
                emissive: 0x111111,
                specular: 0x666666,
                shininess: 30
            });
            
            const materialSide = new THREE.MeshPhongMaterial({ 
                color: 0x00aaff, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                flatShading: true
            });
            
            // 線框材質 (增加科技感)
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });

            // 1. 底部 (正方形)
            const baseGeo = new THREE.PlaneGeometry(baseSize, baseSize);
            const baseMesh = new THREE.Mesh(baseGeo, materialBase);
            baseMesh.rotation.x = -Math.PI / 2; // 放平
            pyramidGroup.add(baseMesh);

            // 輔助函式：建立側面三角形並設定樞紐點
            // pivotX, pivotZ: 旋轉軸相對於中心的偏移
            // rotY: 整個組件的初始 Y 軸旋轉（面向哪邊）
            function createSide(pivotX, pivotZ, rotY, name) {
                const wrapper = new THREE.Group();
                wrapper.position.set(pivotX, 0, pivotZ);
                wrapper.rotation.y = rotY;

                // 實際的三角形幾何體
                // 我們需要讓三角形的底邊中心點對齊 wrapper 的 (0,0,0)
                const shape = new THREE.Shape();
                shape.moveTo(-baseSize / 2, 0);
                shape.lineTo(baseSize / 2, 0);
                // 計算斜邊長度對應的高度 (這裡簡化，直接畫一個三角形)
                // 真正的斜面高度
                const slantHeight = Math.sqrt((baseSize/2)**2 + height**2);
                shape.lineTo(0, slantHeight);
                shape.lineTo(-baseSize / 2, 0);

                const geometry = new THREE.ShapeGeometry(shape);
                const mesh = new THREE.Mesh(geometry, materialSide);
                
                // 添加線框
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, wireframeMaterial);
                mesh.add(line);

                wrapper.add(mesh);
                return wrapper;
            }

            // 建立四個側面
            // 前
            const sideFront = createSide(0, baseSize/2, 0, 'front');
            pyramidGroup.add(sideFront);
            sidePanels.push(sideFront);

            // 後
            const sideBack = createSide(0, -baseSize/2, Math.PI, 'back');
            pyramidGroup.add(sideBack);
            sidePanels.push(sideBack);

            // 左
            const sideLeft = createSide(-baseSize/2, 0, -Math.PI/2, 'left');
            pyramidGroup.add(sideLeft);
            sidePanels.push(sideLeft);

            // 右
            const sideRight = createSide(baseSize/2, 0, Math.PI/2, 'right');
            pyramidGroup.add(sideRight);
            sidePanels.push(sideRight);

            scene.add(pyramidGroup);
        }

        // Three.js 動畫迴圈
        function animateThree() {
            requestAnimationFrame(animateThree);

            // 1. 平滑旋轉 (Lerp)
            // 如果沒有手偵測到，且開啟自動旋轉
            if (!handsDetected) {
                if (isAutoRotate) {
                    targetRotationY += 0.005;
                }
                targetRotationX *= 0.95; // 慢慢回正
            }
            
            pyramidGroup.rotation.y += (targetRotationY - pyramidGroup.rotation.y) * 0.1;
            pyramidGroup.rotation.x += (targetRotationX - pyramidGroup.rotation.x) * 0.1;

            // 2. 平滑展開 (Lerp)
            // 限制 currentUnfoldAngle 範圍
            currentUnfoldAngle += (targetUnfoldAngle - currentUnfoldAngle) * 0.15;
            
            const startAngle = -1.05; // 閉合
            const endAngle = -1.57;   // 展開 (平)

            const actualAngle = startAngle + (endAngle - startAngle) * currentUnfoldAngle;

            sidePanels.forEach(panel => {
                panel.rotation.x = actualAngle;
            });

            renderer.render(scene, camera);
        }

        // --- 2. MediaPipe Hands 處理 ---
        
        let handsDetected = false;

        function onResults(results) {
            loadingDiv.style.display = 'none';
            statusDiv.innerHTML = "系統運作中";
            
            // 繪製背景
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (isShowCamera) {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            } else {
                // 如果關閉相機，顯示深色背景
                canvasCtx.fillStyle = '#111827'; // Tailwind gray-900
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            }
            
            // 繪製手部骨架 (如果開啟)
            if (results.multiHandLandmarks && isShowSkeleton) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                                 {color: '#00FF00', lineWidth: 2});
                    drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});
                }
            }
            canvasCtx.restore();

            // --- 手勢邏輯 ---
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                handsDetected = false;
                feedbackDiv.textContent = "";
                // 沒手的時候，讓它慢慢合起來
                targetUnfoldAngle = 0;
                return;
            }

            handsDetected = true;

            // 1. 雙手偵測：展開邏輯
            if (results.multiHandLandmarks.length >= 2) {
                const hand1 = results.multiHandLandmarks[0][0]; // 手腕點
                const hand2 = results.multiHandLandmarks[1][0]; // 手腕點
                
                // 計算兩手距離 (螢幕座標 0-1)
                const distance = Math.sqrt(
                    Math.pow(hand1.x - hand2.x, 2) + 
                    Math.pow(hand1.y - hand2.y, 2)
                );

                const minD = 0.2;
                const maxD = 0.6;
                let unfoldFactor = (distance - minD) / (maxD - minD);
                unfoldFactor = Math.max(0, Math.min(1, unfoldFactor));
                
                targetUnfoldAngle = unfoldFactor;
                
                if (unfoldFactor > 0.8) feedbackDiv.textContent = "全展開！";
                else if (unfoldFactor > 0.2) feedbackDiv.textContent = "展開中...";
                else feedbackDiv.textContent = "閉合";
                
                // 雙手模式下也可以稍微控制旋轉
                const avgX = (hand1.x + hand2.x) / 2;
                const avgY = (hand1.y + hand2.y) / 2;
                targetRotationY = (avgX - 0.5) * 3; 
                targetRotationX = (avgY - 0.5) * 3;

            } 
            // 2. 單手偵測：旋轉邏輯
            else if (results.multiHandLandmarks.length === 1) {
                const hand = results.multiHandLandmarks[0];
                const indexFinger = hand[8]; // 食指指尖
                
                targetRotationY = (indexFinger.x - 0.5) * 4; 
                targetRotationX = (indexFinger.y - 0.5) * 4;
                
                targetUnfoldAngle = 0;
                feedbackDiv.textContent = "旋轉模式";
            }
        }

        // --- 按鈕事件監聽 ---
        document.getElementById('btn-reset').addEventListener('click', () => {
            targetRotationX = 0;
            targetRotationY = 0;
            targetUnfoldAngle = 0;
        });

        document.getElementById('btn-camera').addEventListener('click', function() {
            isShowCamera = !isShowCamera;
            this.classList.toggle('btn-active');
        });

        document.getElementById('btn-skeleton').addEventListener('click', function() {
            isShowSkeleton = !isShowSkeleton;
            this.classList.toggle('btn-active');
        });

        document.getElementById('btn-autorotate').addEventListener('click', function() {
            isAutoRotate = !isAutoRotate;
            this.classList.toggle('btn-active');
        });

        // 初始化 MediaPipe
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 初始化相機
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        // 啟動程式
        initThree();
        cameraUtils.start()
            .then(() => {
                console.log("Camera started");
            })
            .catch(err => {
                console.error(err);
                statusDiv.innerHTML = "無法啟動相機，請檢查權限";
                loadingDiv.style.display = 'none';
            });

        // 視窗大小調整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        });

        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;

    </script>
</body>
</html>